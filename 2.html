<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MIRROR WORK — WarlockHop Visualizer</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#05060a; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    .card{
      width:min(900px,92vw); border:1px solid rgba(255,255,255,.12);
      border-radius:20px; padding:18px; background:rgba(255,255,255,.03);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
    }
    .top{ display:flex; gap:14px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .title{ font-weight:900; letter-spacing:.10em; text-transform:uppercase; }
    .sub{ opacity:.72; font-size:.92rem; }
    .pill{ padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14);
           background:rgba(255,255,255,.04); font-size:.82rem; opacity:.85; }
    canvas{
      width:100%; height:320px; display:block; border-radius:18px;
      background:
        radial-gradient(900px 420px at 30% 30%, rgba(140,80,255,.14), transparent 60%),
        radial-gradient(900px 420px at 70% 70%, rgba(0,220,255,.10), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.18));
      border:1px solid rgba(255,255,255,.10);
      margin-top:10px;
    }
    audio{ width:100%; margin-top:12px; }
    .hook{
      margin-top:12px; padding:12px 14px; border-radius:16px;
      border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.25);
      line-height:1.35;
    }
    .hook b{ letter-spacing:.06em; text-transform:uppercase; }
  </style>
</head>
<body>
  <div class="card">
    <div class="top">
      <div>
        <div class="title">MIRROR WORK</div>
        <div class="sub">WarlockHop • 140 BPM • Halftime Wobblebass • Mirror Bind</div>
      </div>
      <div class="pill" id="status">Visualizer: idle</div>
    </div>

    <canvas id="viz" width="1200" height="320"></canvas>

    <audio id="audio" controls preload="metadata">
      <source src="mirror-work.mp3" type="audio/mpeg" />
    </audio>

    <div class="hook">
      <b>Hook:</b><br/>
      As you cast, so you carry — yeah.<br/>
      As you reach, so you feel.<br/>
      Try to throw it, it come back — heavy.<br/>
      Try to touch it, it turn real.
    </div>
  </div>

<script>
(() => {
  const audio = document.getElementById('audio');
  const canvas = document.getElementById('viz');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');

  let ac, analyser, freq, raf;
  let crackPts = [];

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    makeCracks();
  }

  function makeCracks(){
    crackPts = [];
    const w = canvas.width, h = canvas.height;
    const cx = w*0.52, cy = h*0.62;
    const rays = 26;
    for (let i=0;i<rays;i++){
      const a = (i/rays) * Math.PI*2;
      const len = (0.18 + Math.random()*0.62) * Math.min(w,h);
      const wig = 5 + Math.random()*18;
      const steps = 6 + Math.floor(Math.random()*10);
      const pts = [];
      for (let s=0;s<=steps;s++){
        const t = s/steps;
        const r = len * t;
        const ox = Math.sin(a*3 + s)*wig*(Math.random()*0.6);
        const oy = Math.cos(a*2 + s)*wig*(Math.random()*0.6);
        pts.push([cx + Math.cos(a)*r + ox, cy + Math.sin(a)*r + oy]);
      }
      crackPts.push(pts);
    }
  }

  window.addEventListener('resize', resize);
  resize();

  function initAudio(){
    if (ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();
    const src = ac.createMediaElementSource(audio);
    analyser = ac.createAnalyser();
    analyser.fftSize = 2048;
    freq = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser);
    analyser.connect(ac.destination);
  }

  function energy(from, to){
    // average bins [from,to)
    let sum = 0, n = 0;
    for (let i=from;i<to;i++){ sum += freq[i]; n++; }
    return n ? (sum/n)/255 : 0;
  }

  function draw(){
    analyser.getByteFrequencyData(freq);
    const w = canvas.width, h = canvas.height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(0,0,w,h);

    const low = energy(0, 60);
    const mid = energy(60, 220);
    const high = energy(220, 520);

    // "mirror pool" ellipse
    const cx = w*0.52, cy = h*0.62;
    const rx = w*(0.34 + low*0.05);
    const ry = h*(0.22 + low*0.04);

    // glow ring
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,255,255,${0.03 + mid*0.05})`;
    ctx.fill();
    ctx.lineWidth = Math.max(2, w*0.003);
    ctx.strokeStyle = `rgba(255,255,255,${0.10 + high*0.22})`;
    ctx.stroke();
    ctx.restore();

    // ripple rings
    const rings = 6;
    for (let r=1;r<=rings;r++){
      const k = r/rings;
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx*k*(0.98+Math.sin(performance.now()*0.002+r)*0.01),
                       ry*k*(0.98+Math.cos(performance.now()*0.002+r)*0.01),
                       0, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255,255,255,${0.05 + (1-k)*0.10 + low*0.08})`;
      ctx.lineWidth = Math.max(1, w*0.0016);
      ctx.stroke();
    }

    // crack lines (brighter with high energy)
    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.lineWidth = Math.max(1, w*0.0013);
    ctx.strokeStyle = `rgba(255,255,255,${0.10 + high*0.35})`;
    for (const pts of crackPts){
      ctx.beginPath();
      for (let i=0;i<pts.length;i++){
        const [x,y] = pts[i];
        const wob = Math.sin(performance.now()*0.003 + i*0.8) * (2 + low*6);
        if (i===0) ctx.moveTo(x, y);
        else ctx.lineTo(x + wob, y - wob);
      }
      ctx.stroke();
    }
    ctx.restore();

    // bass bars at bottom (wobble)
    const bars = 80;
    const step = Math.floor(freq.length / bars);
    const barW = w / bars;
    for (let i=0;i<bars;i++){
      const v = freq[i*step] / 255;
      const bh = (v*v) * (h*0.35);
      const x = i * barW;
      const y = h - bh - 10;
      ctx.fillStyle = `rgba(255,255,255,${0.05 + v*0.25})`;
      ctx.fillRect(x + barW*0.18, y, barW*0.64, bh);
    }

    statusEl.textContent =
      `Visualizer: ${audio.paused ? 'paused' : 'playing'} • low ${(low*100).toFixed(0)}% • mirror ${(high*100).toFixed(0)}%`;

    raf = requestAnimationFrame(draw);
  }

  audio.addEventListener('play', async () => {
    initAudio();
    if (ac.state === 'suspended') await ac.resume();
    cancelAnimationFrame(raf);
    draw();
  });
  audio.addEventListener('pause', () => { cancelAnimationFrame(raf); statusEl.textContent='Visualizer: paused'; });
  audio.addEventListener('ended', () => { cancelAnimationFrame(raf); statusEl.textContent='Visualizer: ended'; });
})();
</script>
</body>
</html>
